# Безопасный Rust

Перед тем как мы погрузимся в изучение языковых конструкций, нужно сказать, что в языке Rust есть два подмножества: безопасный Rust и небезопасный.

По умолчанию мы пишем код на безопасном Rust, и компилятор гарантированно защищает нас от таких вещей, как:

* утечки памяти (memory leak)
* порча данных ввиду множественного доступа (concurrent modification errors)
* гонка за данные в многопоточной среде (data race)
* ошибки сегментации / ошибки доступа по нулевому указателю (segmentation error)
* неопределённое поведение (undefined behavior)

За такие гарантии безопасности мы платим определённой долей свободы, а именно в безопасном Rust коде запрещён ряд операций, таких как:

* работа с памятью при помощи указателя
* вызов кода из библиотек, написанных не на Rust
* работа с потенциально несинхронизированными данными

Такие операции относятся к небезопасному подмножеству Rust и могут быть выполнены только внутри специального `unsafe` блока.

Сразу хочется вас успокоить: при написании back-end приложений (а это основной фокус книги), использовать небезопасный Rust приходится крайне редко. В большинстве приложений можно полностью избежать использования небезопасного Rust.

В процессе изучения мы иногда будем отмечать, что какое-то действие доступно только в небезопасном Rust, и вы сами сможете убедиться, насколько редки эти случаи.
