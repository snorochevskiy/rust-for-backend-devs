# Печать на консоль

Как мы уже видели в примере "Hello World" из главы [Первый взгляд](first-look.md), для печати на консоль используется вызов `println!`.

Функция `println!` не так проста как кажется. Да и не функция это никакая, а макрос. Причём, если вы знакомы с макросами в C, то позвольте вас сразу успокоить: в Rust макросы куда безопаснее и удобнее.

Разбираться с тем, как устроены макросы в Rust, и как именно работает макрос `println!` мы будем потом в главе [Декларативные макросы](declarative-macro.md). А пока что давайте просто посмотрим на примеры использования `println!`, которые нам понадобятся для изучения последующего материала.

***

Чтобы напечатать строку на консоль, нужно просто передать её в вызов `println!` в качестве аргумента.

```rust
println!("Print just text");
```

Если же нужно вывести на консоль значение переменной, то в вызов `println!` необходимо передать два аргумента:

* 1-й аргумент: строка с текстом для печати на консоль, которая в том месте, где мы хотим вывести значение переменной, содержит форматирующую комбинацию `{}`
* 2-й аргумент: переменная, значение которой встанет на место форматирующей комбинации `{}`

Например:

```rust
fn main() {
    let magic_number: i32 = 5;
    println!("Number is {}", magic_number);
}
```

Если скомпилировать и запустить эту программу, то мы увидим следующее:

```
$ rustc main.rs
$ ./main
Number is 5
```

> [!NOTE]
> Это пример сборки и выполнения в Linux. В Windows сборка и запуск будут выглядеть как:
>
> ```
> rustc main.rs
> main.exe
> Number is 5
> ```

Если мы хотим распечатать две переменные, то в форматирующей строке должны указать две `{}` комбинации, и далее передать две переменные:

```rust
let number_1 = 5;
let number_2 = 6;
println!("Number 1 is {}, number 2 is {}", number_1, number_2);
```

Альтернативно, переменную можно указывать не после форматирующей строки, а непосредственно в ней — внутри фигурных скобок:

```rust
let magic_number: i32 = 5;
println!("Number is {magic_number}");
```

Так же имеется комбинированный вариант: когда внутри `{}` мы задаём псевдоним, а после привязываем к этому псевдониму значение.

```rust
let magic_number: i32 = 5;
println!(
    "Number is {num}, num in the power of two is {square}",
    num = magic_number,
    square = magic_number * magic_number
);
```

***

Вышеуказанным образом, выводить на консоль можно только значения типов, для которых определён трэйт `std::fmt::Display` . Про трейты мы поговорим позже, а пока что нам нужно знать то, что через `{}` можно передавать только значения типов, для которых явно прописано как значениея этих типов преобразуются в строки.

Для всех примитивных типов в стандартной бибилиотеке Rust уже имеется реализация `std::fmt::Display` , что позволяет непосредственно выводить их через `println!`. Но для большей части типов (например, для массивов) это не так.

Однако, если в вызове `println!` в форматирующей строке заменить `{}` на `{:?}`, то мы сможем выводить значения типов, для которых определён трэйт `std::fmt::Debug`, а таких типов подавляющее большинство.

Пока что не заостряйте своё внимание на этом моменте, так как мы его коснёмся еще не раз.
