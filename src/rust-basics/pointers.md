# Указатели

## unsafe

В языке Rust имеются указатели, которые работают практически так же, как и в C. Но как мы сказали в самом начале книги, работа с указателями запрещена в безопасном Rust. Именно поэтому в этой главе мы активно будем использовать `unsafe`.

В главе про статические переменным, мы уже видели `unsafe` блок:

```rust
unsafe {
    код
}
```

Внутри такого блока можно использовать небезопасные операции, включая работу с указателями.

Так же можно пометить целую функцию ключевым словом `unsafe`.

```rust
unsafe fn функия() {
    ...
}
```

В таком случае, всё тело функции становится `unsafe` блоком. Причём такую `unsafe` функцию можно вызывать только либо из `unsafe` блока, либо из другой `unsafe` функции.

## Работа с указателями

Как и в C, в Rust указатель является переменной, которая хранит адрес в памяти. При этом на уровне исходного кода программы, у указателя имеется тип, представляющий информацию о типе значения, чей адрес хранится в указателе.

Тип указателя получается путем добавления `*const` (для мутабельного) или `*mut` (для немутабельного указателя), перед типом значения, на которое ссылается указатель.

Например, если переменная имеет тип `i32`, то немутабельный указатель на неё будем иметь тип `*const i32`.

```rust
let p1: *const i32;  // константный указатель на i32
let p2: *mut i32;    // мутабельный указатель на i32
let p3: *mut String; // мутабельный указатель на строку
```

Есть несколько способов получить указатель на объект:

1\) Преобразованием из ссылки

```rust
let mut v: i32 = 5;
let const_ptr: *const i32 = &v as *const i32;
let mut_prt:   *mut i32   = &mut v as *mut i32;
```

2\) При помощи `&raw` (пришел на смену макросам `addr_of` и `addr_of_mut`).

```rust
let mut v: i32 = 5;
let const_ptr: *const i32 = &raw const v;
let mut_prt:   *mut i32   = &raw mut v;
```

3\) Макросы [addr_of](https://doc.rust-lang.org/stable/std/ptr/macro.addr_of.html) и [addr_of_mut](https://doc.rust-lang.org/stable/std/ptr/macro.addr_of_mut.html) (более старый вариант).

```rust
let mut v: i32 = 5;
let const_ptr: *const i32 = std::ptr::addr_of!(v);
let mut_prt:   *mut i32   = std::ptr::addr_of_mut!(v);
```

Для того, чтобы разыменовать указатель (обратиться к значению по адресу), как и в C, используется оператор `*`.

Рассмотрим простой пример.

```rust
fn main() {
    let a = 5;
    let ptr = (&a) as *const i32; // берём ссылку и преобразуём её в указатель
    unsafe {
        // разыменовываем указатель, чтобы получить значение переменно a
        println!("{}", *ptr); // 5
    }
}
```

Приведение ссылки к указателю является безопасной операцией, и может выполняться вне блока `unsafe`. Но разыменовывание указателя, или преобразование указателя в ссылку требуют `unsafe`.

## Обход ограничения ссылок

Напомним, что в Rust, в каждой точке программы, на любой объект мы может иметь либо одну мутабельную ссылку, либо сколько угодно немутабельных. В подавляющем большистве ситуаций, особенно при написании бекендов, это ограничение никак не мешает. Однако, при написании структур данных или алгоритмов, часто может понадобиться иметь более одной мутабельной ссылки на один и тот же объект.

Например, в двунаправленном списке, нам одновременно нужны две мутабельные ссылки на одни и те же элементы (одна ссылка со стороны головы списка, другая с хвоста).

![](img/pointers_list.svg)

Дургой пример — сортировка слиянием (merge sort), которая подразумевает разделение исходной последовательности на участки, каждый из которых сортируется отдельно, а следовательно должен иметь свою мутабельную ссылку.

`unsafe` блок не позволяет напрямую нарушить правило безопасности ссылок, однако `unsafe` позволяет создать дополнительную ссылку через промежуточный указатель:\
мутабельная сслыка → указатель → еще одна мутабельная ссылку.

```rust
fn main() {
    let mut a = 5;
    unsafe {
        let r1: &mut i32 = &mut a; // первая мутабельная ссылка
        let ptr: *mut i32 = r1 as *mut i32; // мутабельный указатель
        let r2: &mut i32 = ptr.as_mut().unwrap(); // указатель во вторую ссылку
        inc(r1);
        inc(r2);
    }
    println!("{a}"); // 7
}

fn inc(a: &mut i32) {
    *a = *a + 1;
}
```

Разумеется этот приём можно использовать только при крайней необходимости. Так же, настоятельно рекомендуется:

* хорошо покрывать тестами код, использующий unsafe
* осуществлять диагностику кода при помощи [Miri](https://github.com/rust-lang/miri) — утилиты для поиска проблем в unsafe коде

