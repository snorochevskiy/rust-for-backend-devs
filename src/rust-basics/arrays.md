# Массивы

Массивы в Rust представляют из себя непрерывную последовательность значений, размер которой известен на <ins>момент компиляции</ins>.

Тип массива состоит из двух частей: тип элементов массива и количество элементов.

```
[тип_элементов; количество_элементов]
```

Например, массив из трёх элементов типа `i32`:

```rust
let arr: [i32; 3] = [1, 2, 3];
```

Размер массива нельзя задать во время выполнения программы (например, считать с консоли желаемый размер и сконструировать его). Он обязательно должен быть известен во время компиляции, что делает массив полезным в редких случаях.

Например, массив из четырёх байт хорошо подходит для хранения IPv4 адреса.

```rust
fn main() {
  let mut arr: [u8; 4] = [192, 168, 0, 1];
  println!("Array is {arr:?}");
  // Напечатает: Array is [192, 168, 0, 1]
}
```

> [!NOTE]
> Как мы видим, здесь для вывода на консоль мы используем форматирующую последовательность `{:?}` вместо `{}`. Как мы говорили в разделе [Вывод на консоль](console-output.md), это необходимо, так как массив не реализует трэйт `std::fmt::Display`, но, как и почти все стандартные типы, реализует `std::fmt::Debug`.

Индексация элементов массива начинается с нуля.

```rust
fn main() {
  let arr: [u8; 4] = [192, 168, 0, 1];
  println!("{}", arr[0]); // 192
}
```

Как и любые другие переменные, переменная-массив по умолчанию немутабельна. Чтобы массив можно было изменять, он должен быть объявлен с ключевым словом `mut`.

```rust
fn main() {
  let mut arr = [1,2,3];
  arr[1] = 55;
  println!("Array is {arr:?}");
  // Напечатает: Array is [1, 55, 3]
}
```

Массивы, объявленные внутри функций, всегда располагаются на стеке.

Существует механизм, позволяющий перенести массив в кучу, однако придумать практическое применение для такой операции весьма непросто.
