# Вектор

Как мы уже знаем, размер массива должен быть известен во время компиляции, что делает его бесполезным для сценариев, при которых размер вычисляется в процессе работы программы.

Тип [Vec](https://doc.rust-lang.org/std/vec/struct.Vec.html) (вектор), представляет из себя непрерывную последовательность элементов, размер которой может определяться и изменяться во время выполнения программы.

> [!NOTE]
> `Vec<T>` является обобщённой (generic) структурой. И генерики, и структуры мы изучим только несколько глав спустя, однако, вектор является настолько вездесущей стуруктурой данных, что изучать даже базовые конструкции Rust без него будет очень сложно. Поэтому, на данном этапе мы только разберёмся как с ним работать, и как он располагается в памяти.\
Если же вы знакомы с C++, то вы уже, скорее всего, провели аналогию с шаблонным классом `std::vector`, и оказались полностью правы.\
Если вы знакомы с Java, то считайте вектор близким родственником класс `ArrayList<T>`.

Для начала, рассмотрим пример использования вектора:

```rust
fn main() {
  // Создаём пустой вектор
  let mut my_vec: Vec<i32> = Vec::new();

  my_vec.push(1); // Добавляем 1 в конец вектора
  my_vec.push(2); // Добавляем 2 в конец вектора
  my_vec.push(3); // Добавляем 3 в конец вектора

  // Копируем в переменную third значение элемента с индексом 2 (индексация с нуля)
  let third: i32 = my_vec[2];
  println!("3-rd element: {}", third);
}
```

Как видно, с точки зрения использования, вектор можно рассматривать просто, как динамически расширяемый массив.

## Лэйаут (расположение) в памяти

Теперь поговорим о том, как вектор хранится в памяти. Когда мы создаём переменную вектора, то на стеке располагается только его "служебная информация", а сами данные хранятся в куче в буфере, который вектор для себя аллоцирует в момент своего создания.

На стеке хранятся такие 3 поля:

* указатель на начало буфера в куче — в этом буфере хранятся сами элементы вектора
* счётчик количества элементов, записанных в буфере в куче
* размер буфера в куче

Лэйаут (layout) вектора из примера выше в оперативной памяти выглядит так:

![](img/vector_in_memory.svg)

Размер буфера в куче, который вектор изначально создаёт не стандартизирован, но да данной диаграмме мы предположили, что он равен 5.

Если желаемый размер буфера в куче известен заранее, то его можно задать явно заменив `Vec::new()` на `Vec::with_capacity(размер)`. Это приведёт к тому, что вектор аллоцирует первичный буфер в куче ровно такого размера, чтобы иметь возможность вместить ровно заданное количество элементов.

При добавлении элементов в вектор, счётчик элементов в буфере (len) увеличивается, пока не достигнет максимального размера буфера (capacity). Когда буфер будет полностью заполнен, вектор аллоцирует новый буфер большего размера, скопирует в него все элементы из старого буфера, после чего старый буфер будет удалён. Добавление элементов продолжится уже в новый буфер.

### Макрос vec!

Для создания вектора с элементами в предыдущем примере, мы сначала создали пустой вектор, а затем один за другим добавили в него все необходимые элементы. Согласитесь, что добавлять элементы по одному — весьма неудобно.
Поэтому, учитывая, что вектор является найболее часто используемой структурой данных, в стандартную библиотеку Rust включили специальный макрос `vec![]`, который берёт на себя бремя поэлементного добавления элементов в вектор.

При помощи этого макроса, мы можем переписать пример выше таким образом:

```rust
fn main() {
  let mut my_vec = vec![1,2,3];

  let third: i32 = my_vec[2];
  println!("3-rd element: {}", third);
}
```

Как работает этот макрос станет понятно только после прочтения главы [Декларативные макросы](declarative-macro.md).
