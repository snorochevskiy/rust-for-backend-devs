# Слайсы

Подобно тому, как ссылка указывает на данные, принадлежащие некой переменной, **слайс** — это специальная ссылка, которая указывает на последовательность элементов, как правило, принадлежащих другой переменной (вектору, массиву, и т.д.).

Аналогично тому, как ссылка создаётся оператором `&`, слайс создаётся оператором `&[]`.

```rust
let arr: [i32; 5]  = [0, 1, 2, 3, 4]; // массив
let slice1: &[i32] = &arr[..];        // слайс на все элементы массива
let slice2: &[i32] = &arr[2..=4];     // слайс на элементы со 2го по 4-й включительно

// альтернативно можно было бы написать 
// let slice2: &[i32] = &arr[2..5]; // то есть со 2-го до 5-го не включительно
```

Слайс позволяет обращаться к элементам по их индексу (относительно начала слайса, а не относительно начала оригинальной последовательности).

```rust
fn main() {
  let arr = [0, 1, 2, 3, 4];
  let slice: &[i32] = &arr[2..=4]; // слайс на элементы со 2го по 4-й
  println!("{}", slice.len()); // 3 (размер слайса)
  println!("{}", slice[2]);    // 4 (2-й по индексу элемент слайса)
}
```

В отличие от обычных ссылок, которые, как правило, эфемерны (не представлены отдельными ячейками в памяти), слайсы хранятся в памяти в виде пары полей:

* адрес первого элемента последовательности
* количество элементов

![](img/slice_to_array.svg)

По умолчанию слайсы, как и ссылки, — немутабельны. Для того, чтобы сделать мутабельный слайс, нужно использовать ключевое слово `mut`.

Рассмотрим пример изменения элементов вектора посредством мутабельного слайса:

```rust
fn main() {
  let mut v: Vec<i32> = Vec::with_capacity(5);
  v.push(0);
  v.push(1);
  v.push(2);
  v.push(3);

  let slice: &mut [i32] = &mut v[1..3]; // слайс на элементы со 1го до 3го
  slice[0] = 9;

  println!("v[1]: {}", v[1]); // 9
}
```

В памяти это соотношение вектора и слайса выглядит так:

![](img/slice_to_vec.svg)

