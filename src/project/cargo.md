# Cargo

Использовать напрямую компилятор `rustc` можно для сборки небольших тестовых программ, однако при написании реального приложения, которое использует сторонние библиотеки, не обойтись без системы сборки.

В большинстве языков программирования система сборки поставляется отдельно от тулчейна самого языка. Например, в Java популярны Maven и Gradle, которые распространяются отдельно от JDK. Но в случае с Rust, утилита `rustup` устанавливает систему сборки одновременно вместе с компилятором. И называется эта система сборки — Cargo.

Cargo умеет:

* создавать новый Rust проект
* собирать исполняемый файл / библиотеку
* автоматически скачивать и компилировать зависимости (библиотеки)
* запускать юнит и интеграционные тесты
* запускать бенчмарки, и агрегировать результаты
* скачивать и собирать различные утилиты из экосистемы Rust

## Создание проекта

Для того чтобы создать новый Rust проект, управляемый системой сборки Cargo, нужно выполнить команду `cargo new имя_проекта`.

Для примера, создадим hello world проект:

```
cargo new hello_world --bin
```

Опция `--bin` указывает, что мы хотим создать исполняемую программу (тип проекта по умолчанию). Если бы мы хотели создать библиотеку, то следовало бы указать опцию `--lib`.

После выполнения команды, Cargo создаст такое дерево каталогов:

```
hello_world/
├── Cargo.toml
└── src/
    └── main.rs
```

Это стандартная структура Cargo проекта:

* исходный код располагается внутри директории `src`.
  * Если мы создаём исполняемую программу, то главным файлом программы является `main.rs`.
  * Если мы создаём библиотеку, то главным файлом является `lib.rs`
* `Cargo.toml` — файл конфигурации проекта, из которого Cargo берёт основные настройки

Cargo наполнит `src/main.rs` "болванкой" программы Hello world:

```rust
fn main() {
    println!("Hello, world!");
}
```

## Cargo.toml

Файл `Cargo.toml` содержит конфигурацию проекта на языке TOML (Tom's Obvious, Minimal Language).

Сразу после создания, наш `Cargo.toml` должен выглядеть примерно так:

```toml
[package]
name = "hello_world"
version = "0.1.0"
edition = "2024"

[dependencies]
```

Секция `package` содержит основную информацию о проекте:

* `name` — имя крэйта (о них мы поговорим позже). По умочанию имя исполняемого файла будет таким же, как это имя.
* `version` — версия программы или библиотеки.
* `edition` — версия языка  Rust, которой соответствует код программы. [Подробнее](https://doc.rust-lang.org/edition-guide/editions/).

Секция `dependencies` служит для указания внешних зависимостей (библиотек) для программы. О них мы поговорим позже.

## Сборка и запуск

Для того чтобы собрать исполняемый файл надо воспользоваться командой

```
cargo build
```

После этого исполняемый файл должен появиться в поддиректории `target/debug`. Запустим его, чтобы убедиться, что он работает:

На Linux/Mac:
```
$ ./target/debug/hello_world 
Hello, world!
```

На Windows:
```
target\debug\hello_world 
Hello, world!
```

Как вы могли догадаться по имени директории `target/debug`, Cargo по умолчанию собрал исполняемый файл с отладочными настройками. Если нам нужна оптимизированная релизная сборка без отладочной информации, то в команду сборки нужно передать флаг `--release`.

```
cargo build --release
```

Исполняемый файл появится в директории `target/release`.

---

Также, у Cargo есть команда, которая объединяет сборку и запуск — `run`:

```
$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/hello_world`
Hello, world!
```
